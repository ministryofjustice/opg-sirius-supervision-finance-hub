// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: finance_client.sql

package store

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const checkClientExistsByCourtRef = `-- name: CheckClientExistsByCourtRef :one
SELECT EXISTS (SELECT 1 FROM finance_client WHERE court_ref = $1)
`

func (q *Queries) CheckClientExistsByCourtRef(ctx context.Context, courtRef pgtype.Text) (bool, error) {
	row := q.db.QueryRow(ctx, checkClientExistsByCourtRef, courtRef)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const getAccountInformation = `-- name: GetAccountInformation :one
WITH balances AS (SELECT fc.id,
                         COALESCE(SUM(
                                          CASE
                                              WHEN la.status = 'ALLOCATED'
                                                  THEN la.amount
                                              WHEN la.status IN ('UNAPPLIED', 'REAPPLIED') AND la.invoice_id IS NOT NULL
                                                  THEN la.amount
                                              ELSE 0
                                              END), 0)::INT      AS paid,
                         ABS(COALESCE(SUM(
                                              CASE
                                                  WHEN la.status IN ('UNAPPLIED', 'REAPPLIED')
                                                      THEN la.amount
                                                  ELSE 0
                                                  END), 0))::INT AS credit
                  FROM finance_client fc
                           LEFT JOIN ledger l ON fc.id = l.finance_client_id AND l.status = 'CONFIRMED'
                           LEFT JOIN ledger_allocation la ON l.id = la.ledger_id
                  WHERE fc.client_id = $1
                  GROUP BY fc.id)
SELECT COALESCE(SUM(i.amount), 0)::INT - b.paid AS outstanding,
       b.credit,
       fc.payment_method
FROM finance_client fc
         JOIN balances b ON fc.id = b.id
         LEFT JOIN invoice i ON fc.id = i.finance_client_id
GROUP BY fc.payment_method, b.paid, b.credit
`

type GetAccountInformationRow struct {
	Outstanding   int32
	Credit        int32
	PaymentMethod string
}

func (q *Queries) GetAccountInformation(ctx context.Context, clientID int32) (GetAccountInformationRow, error) {
	row := q.db.QueryRow(ctx, getAccountInformation, clientID)
	var i GetAccountInformationRow
	err := row.Scan(&i.Outstanding, &i.Credit, &i.PaymentMethod)
	return i, err
}

const getClientByCourtRef = `-- name: GetClientByCourtRef :one
SELECT id AS finance_client_id, client_id FROM finance_client WHERE court_ref = $1
`

type GetClientByCourtRefRow struct {
	FinanceClientID int32
	ClientID        int32
}

func (q *Queries) GetClientByCourtRef(ctx context.Context, courtRef pgtype.Text) (GetClientByCourtRefRow, error) {
	row := q.db.QueryRow(ctx, getClientByCourtRef, courtRef)
	var i GetClientByCourtRefRow
	err := row.Scan(&i.FinanceClientID, &i.ClientID)
	return i, err
}

const getCreditBalanceByCourtRef = `-- name: GetCreditBalanceByCourtRef :one
SELECT ABS(COALESCE(SUM(la.amount), 0))::INT AS credit
FROM finance_client fc
         LEFT JOIN ledger l ON fc.id = l.finance_client_id
         LEFT JOIN ledger_allocation la ON l.id = la.ledger_id
WHERE fc.court_ref = $1
  AND la.status IN ('UNAPPLIED', 'REAPPLIED')
`

func (q *Queries) GetCreditBalanceByCourtRef(ctx context.Context, courtRef pgtype.Text) (int32, error) {
	row := q.db.QueryRow(ctx, getCreditBalanceByCourtRef, courtRef)
	var credit int32
	err := row.Scan(&credit)
	return credit, err
}

const getPendingOutstandingBalance = `-- name: GetPendingOutstandingBalance :one
SELECT COALESCE(SUM(
                        CASE
                            WHEN la.status = 'ALLOCATED'
                                THEN la.amount
                            WHEN la.status IN ('UNAPPLIED', 'REAPPLIED') AND la.invoice_id IS NOT NULL
                                THEN la.amount
                            ELSE 0
                            END), 0)::INT
FROM finance_client fc
         LEFT JOIN ledger l ON fc.id = l.finance_client_id AND l.status = 'CONFIRMED'
         LEFT JOIN ledger_allocation la ON l.id = la.ledger_id
WHERE fc.client_id = $1
GROUP BY fc.id
`

func (q *Queries) GetPendingOutstandingBalance(ctx context.Context, clientID int32) (int32, error) {
	row := q.db.QueryRow(ctx, getPendingOutstandingBalance, clientID)
	var column_1 int32
	err := row.Scan(&column_1)
	return column_1, err
}

const getReversibleBalanceByCourtRef = `-- name: GetReversibleBalanceByCourtRef :one
WITH ledger_data AS (
    SELECT
        fc.id AS client_id,
        fc.court_ref,
        SUM(CASE
                WHEN la.status NOT IN ('PENDING', 'UN ALLOCATED') AND l.status = 'CONFIRMED'
                    AND la.invoice_id IS NOT NULL THEN la.amount
                ELSE 0
            END) AS received,
        SUM(CASE
                WHEN la.status IN ('UNAPPLIED', 'REAPPLIED') AND l.status = 'CONFIRMED' THEN la.amount
                ELSE 0
            END) AS credit
    FROM finance_client fc
             LEFT JOIN ledger l ON fc.id = l.finance_client_id
             LEFT JOIN ledger_allocation la ON l.id = la.ledger_id
    GROUP BY fc.id, fc.court_ref
)
SELECT
    COALESCE(ledger_data.received, 0)::INT + ABS(COALESCE(ledger_data.credit, 0))::INT AS balance
FROM ledger_data
WHERE ledger_data.court_ref = $1
`

func (q *Queries) GetReversibleBalanceByCourtRef(ctx context.Context, dollar_1 pgtype.Text) (int32, error) {
	row := q.db.QueryRow(ctx, getReversibleBalanceByCourtRef, dollar_1)
	var balance int32
	err := row.Scan(&balance)
	return balance, err
}

const updateClient = `-- name: UpdateClient :exec
UPDATE finance_client
SET court_ref = $1
WHERE client_id = $2
`

type UpdateClientParams struct {
	CourtRef pgtype.Text
	ClientID int32
}

func (q *Queries) UpdateClient(ctx context.Context, arg UpdateClientParams) error {
	_, err := q.db.Exec(ctx, updateClient, arg.CourtRef, arg.ClientID)
	return err
}

const updatePaymentMethod = `-- name: UpdatePaymentMethod :exec
UPDATE finance_client
SET payment_method = $1
WHERE client_id = $2
`

type UpdatePaymentMethodParams struct {
	PaymentMethod string
	ClientID      int32
}

func (q *Queries) UpdatePaymentMethod(ctx context.Context, arg UpdatePaymentMethodParams) error {
	_, err := q.db.Exec(ctx, updatePaymentMethod, arg.PaymentMethod, arg.ClientID)
	return err
}
