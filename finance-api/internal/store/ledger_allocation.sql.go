// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: ledger_allocation.sql

package store

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createLedgerAllocationForFeeReduction = `-- name: CreateLedgerAllocationForFeeReduction :one
insert into ledger_allocation (id, ledger_id, invoice_id, datetime, amount, status, reference,
                                                   notes, allocateddate, batchnumber, source,
                                                   transaction_type)
VALUES (nextval('ledger_allocation_id_seq'::regclass), $1, $2, now(), $3, 'Confirmed', null, null, null, null, null,
        null) returning id, ledger_id, invoice_id, datetime, amount, status, reference, notes, allocateddate, batchnumber, source, transaction_type
`

type CreateLedgerAllocationForFeeReductionParams struct {
	LedgerID  pgtype.Int4
	InvoiceID pgtype.Int4
	Amount    int32
}

func (q *Queries) CreateLedgerAllocationForFeeReduction(ctx context.Context, arg CreateLedgerAllocationForFeeReductionParams) (LedgerAllocation, error) {
	row := q.db.QueryRow(ctx, createLedgerAllocationForFeeReduction, arg.LedgerID, arg.InvoiceID, arg.Amount)
	var i LedgerAllocation
	err := row.Scan(
		&i.ID,
		&i.LedgerID,
		&i.InvoiceID,
		&i.Datetime,
		&i.Amount,
		&i.Status,
		&i.Reference,
		&i.Notes,
		&i.Allocateddate,
		&i.Batchnumber,
		&i.Source,
		&i.TransactionType,
	)
	return i, err
}

const updateLedgerAllocationAdjustment = `-- name: UpdateLedgerAllocationAdjustment :exec
WITH filtered_ledger_allocation AS (
    SELECT lc.id
    from ledger l
             inner join ledger_allocation lc on lc.ledger_id = l.id
    where l.id = $1
      and l.type IN ('CREDIT MEMO', 'CREDIT WRITE OFF')
)
UPDATE ledger_allocation
SET status = 'APPROVED'
FROM filtered_ledger_allocation fla
WHERE ledger_allocation.id = fla.id
`

func (q *Queries) UpdateLedgerAllocationAdjustment(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, updateLedgerAllocationAdjustment, id)
	return err
}
