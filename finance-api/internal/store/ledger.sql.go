// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: ledger.sql

package store

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countDuplicateLedger = `-- name: CountDuplicateLedger :one
SELECT COUNT(*)
FROM ledger l
        JOIN finance_client fc ON fc.id = l.finance_client_id
WHERE l.amount = $1
 AND l.status = 'CONFIRMED'
 AND ($2 IS TRUE OR l.bankdate = $3)
 AND ($4 IS TRUE OR l.datetime::DATE = ($5::TIMESTAMP)::DATE)
 AND l.type = $6
 AND fc.court_ref = $7
 AND COALESCE(l.pis_number, 0) = COALESCE($8, 0)
`

type CountDuplicateLedgerParams struct {
	Amount           int32
	SkipBankDate     pgtype.Bool
	BankDate         pgtype.Date
	SkipReceivedDate pgtype.Bool
	ReceivedDate     pgtype.Timestamp
	Type             string
	CourtRef         pgtype.Text
	PisNumber        pgtype.Int4
}

func (q *Queries) CountDuplicateLedger(ctx context.Context, arg CountDuplicateLedgerParams) (int64, error) {
	row := q.db.QueryRow(ctx, countDuplicateLedger,
		arg.Amount,
		arg.SkipBankDate,
		arg.BankDate,
		arg.SkipReceivedDate,
		arg.ReceivedDate,
		arg.Type,
		arg.CourtRef,
		arg.PisNumber,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createLedger = `-- name: CreateLedger :one
INSERT INTO ledger (id, datetime, finance_client_id, amount, notes, type, status, fee_reduction_id, created_at,
                    created_by, reference, method)
SELECT NEXTVAL('ledger_id_seq'),
       NOW(),
       fc.id,
       $2,
       $3,
       $4,
       $5,
       $6,
       NOW(),
       $7,
       gen_random_uuid(),
       ''
FROM finance_client fc
WHERE client_id = $1
RETURNING id
`

type CreateLedgerParams struct {
	ClientID       int32
	Amount         int32
	Notes          pgtype.Text
	Type           string
	Status         string
	FeeReductionID pgtype.Int4
	CreatedBy      pgtype.Int4
}

func (q *Queries) CreateLedger(ctx context.Context, arg CreateLedgerParams) (int32, error) {
	row := q.db.QueryRow(ctx, createLedger,
		arg.ClientID,
		arg.Amount,
		arg.Notes,
		arg.Type,
		arg.Status,
		arg.FeeReductionID,
		arg.CreatedBy,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const createLedgerForCourtRef = `-- name: CreateLedgerForCourtRef :one
INSERT INTO ledger (id, datetime, bankdate, finance_client_id, amount, notes, type, status, created_at, created_by,
                    reference, method, pis_number)
SELECT NEXTVAL('ledger_id_seq'),
       $1,
       $2,
       fc.id,
       $3,
       $4,
       $5,
       $6,
       NOW(),
       $7,
       gen_random_uuid(),
       '',
       $8
FROM finance_client fc
WHERE court_ref = $9
RETURNING id
`

type CreateLedgerForCourtRefParams struct {
	ReceivedDate pgtype.Timestamp
	BankDate     pgtype.Date
	Amount       int32
	Notes        pgtype.Text
	Type         string
	Status       string
	CreatedBy    pgtype.Int4
	PisNumber    pgtype.Int4
	CourtRef     pgtype.Text
}

func (q *Queries) CreateLedgerForCourtRef(ctx context.Context, arg CreateLedgerForCourtRefParams) (int32, error) {
	row := q.db.QueryRow(ctx, createLedgerForCourtRef,
		arg.ReceivedDate,
		arg.BankDate,
		arg.Amount,
		arg.Notes,
		arg.Type,
		arg.Status,
		arg.CreatedBy,
		arg.PisNumber,
		arg.CourtRef,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const getLedgerForPayment = `-- name: GetLedgerForPayment :one
SELECT l.id
FROM ledger l
         JOIN finance_client fc ON fc.id = l.finance_client_id
WHERE l.amount = $1
  AND l.status = 'CONFIRMED'
  AND l.bankdate = $2
  AND l.type = $3
  AND fc.court_ref = $4
LIMIT 1
`

type GetLedgerForPaymentParams struct {
	Amount   int32
	BankDate pgtype.Date
	Type     string
	CourtRef pgtype.Text
}

func (q *Queries) GetLedgerForPayment(ctx context.Context, arg GetLedgerForPaymentParams) (int32, error) {
	row := q.db.QueryRow(ctx, getLedgerForPayment,
		arg.Amount,
		arg.BankDate,
		arg.Type,
		arg.CourtRef,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}
