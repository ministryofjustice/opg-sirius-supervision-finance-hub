// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: ledger.sql

package store

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createLedgerForFeeReduction = `-- name: CreateLedgerForFeeReduction :one
insert into ledger (id, reference, datetime, method, amount, notes, type, status, finance_client_id,
                                        parent_id, fee_reduction_id, confirmeddate, bankdate, batchnumber, bankaccount,
                                        line, source,
                                        createddate, createdby_id)
VALUES (nextval('ledger_id_seq'::regclass), gen_random_uuid(), now(), $1, $2, $3, $4, 'Status', $5, null, $6, null,
        null, null, null, null, null, now(), $7) returning id, reference, datetime, method, amount, notes, type, status, finance_client_id, parent_id, fee_reduction_id, confirmeddate, bankdate, batchnumber, bankaccount, source, line, createddate, createdby_id
`

type CreateLedgerForFeeReductionParams struct {
	Method          string
	Amount          int32
	Notes           pgtype.Text
	Type            string
	FinanceClientID pgtype.Int4
	FeeReductionID  pgtype.Int4
	CreatedbyID     pgtype.Int4
}

func (q *Queries) CreateLedgerForFeeReduction(ctx context.Context, arg CreateLedgerForFeeReductionParams) (Ledger, error) {
	row := q.db.QueryRow(ctx, createLedgerForFeeReduction,
		arg.Method,
		arg.Amount,
		arg.Notes,
		arg.Type,
		arg.FinanceClientID,
		arg.FeeReductionID,
		arg.CreatedbyID,
	)
	var i Ledger
	err := row.Scan(
		&i.ID,
		&i.Reference,
		&i.Datetime,
		&i.Method,
		&i.Amount,
		&i.Notes,
		&i.Type,
		&i.Status,
		&i.FinanceClientID,
		&i.ParentID,
		&i.FeeReductionID,
		&i.Confirmeddate,
		&i.Bankdate,
		&i.Batchnumber,
		&i.Bankaccount,
		&i.Source,
		&i.Line,
		&i.Createddate,
		&i.CreatedbyID,
	)
	return i, err
}

const updateLedgerAdjustment = `-- name: UpdateLedgerAdjustment :one
WITH filtered_ledger_allocation AS (
    SELECT lc.id
    from ledger l
             inner join ledger_allocation lc on lc.ledger_id = l.id
    where l.id = $1
      and l.type IN ('CREDIT MEMO', 'CREDIT WRITE OFF')
)
UPDATE ledger_allocation
SET status = 'APPROVED'
FROM filtered_ledger_allocation fla
WHERE ledger_allocation.id = fla.id
returning ledger_allocation.id, ledger_allocation.ledger_id, ledger_allocation.invoice_id, ledger_allocation.datetime, ledger_allocation.amount, ledger_allocation.status, ledger_allocation.reference, ledger_allocation.notes, ledger_allocation.allocateddate, ledger_allocation.batchnumber, ledger_allocation.source, ledger_allocation.transaction_type
`

func (q *Queries) UpdateLedgerAdjustment(ctx context.Context, id int32) (LedgerAllocation, error) {
	row := q.db.QueryRow(ctx, updateLedgerAdjustment, id)
	var i LedgerAllocation
	err := row.Scan(
		&i.ID,
		&i.LedgerID,
		&i.InvoiceID,
		&i.Datetime,
		&i.Amount,
		&i.Status,
		&i.Reference,
		&i.Notes,
		&i.Allocateddate,
		&i.Batchnumber,
		&i.Source,
		&i.TransactionType,
	)
	return i, err
}
