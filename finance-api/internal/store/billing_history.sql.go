// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: billing_history.sql

package store

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getFeeReductionEvents = `-- name: GetFeeReductionEvents :many
SELECT fr.type, fr.startdate, fr.enddate, fr.datereceived, fr.notes, fr.created_at, fr.created_by, fr.cancelled_at, fr.cancelled_by, fr.cancellation_reason
FROM fee_reduction fr
JOIN finance_client fc ON fc.id = fr.finance_client_id
WHERE fc.client_id = $1
AND (fr.created_at IS NOT NULL OR fr.cancelled_at IS NOT NULL)
`

type GetFeeReductionEventsRow struct {
	Type               string
	Startdate          pgtype.Date
	Enddate            pgtype.Date
	Datereceived       pgtype.Date
	Notes              string
	CreatedAt          pgtype.Date
	CreatedBy          pgtype.Int4
	CancelledAt        pgtype.Date
	CancelledBy        pgtype.Int4
	CancellationReason pgtype.Text
}

func (q *Queries) GetFeeReductionEvents(ctx context.Context, clientID int32) ([]GetFeeReductionEventsRow, error) {
	rows, err := q.db.Query(ctx, getFeeReductionEvents, clientID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetFeeReductionEventsRow
	for rows.Next() {
		var i GetFeeReductionEventsRow
		if err := rows.Scan(
			&i.Type,
			&i.Startdate,
			&i.Enddate,
			&i.Datereceived,
			&i.Notes,
			&i.CreatedAt,
			&i.CreatedBy,
			&i.CancelledAt,
			&i.CancelledBy,
			&i.CancellationReason,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGeneratedInvoices = `-- name: GetGeneratedInvoices :many
SELECT i.id invoice_id, reference, feetype, amount, createdby_id, coalesce(confirmeddate, createddate) invoice_date
FROM invoice i
         JOIN finance_client fc ON fc.id = i.finance_client_id
WHERE fc.client_id = $1
ORDER BY COALESCE(confirmeddate, createddate) DESC
`

type GetGeneratedInvoicesRow struct {
	InvoiceID   int32
	Reference   string
	Feetype     string
	Amount      int32
	CreatedbyID pgtype.Int4
	InvoiceDate pgtype.Date
}

func (q *Queries) GetGeneratedInvoices(ctx context.Context, clientID int32) ([]GetGeneratedInvoicesRow, error) {
	rows, err := q.db.Query(ctx, getGeneratedInvoices, clientID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetGeneratedInvoicesRow
	for rows.Next() {
		var i GetGeneratedInvoicesRow
		if err := rows.Scan(
			&i.InvoiceID,
			&i.Reference,
			&i.Feetype,
			&i.Amount,
			&i.CreatedbyID,
			&i.InvoiceDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPendingLedgerAllocations = `-- name: GetPendingLedgerAllocations :many
SELECT i.id invoice_id, l.id ledger_id, i.reference, l.type, la.amount, l.notes, l.confirmeddate, l.createdby_id, l.status, l.datetime
FROM ledger_allocation la
         JOIN ledger l ON l.id = la.ledger_id
         JOIN invoice i ON i.id = la.invoice_id
         JOIN finance_client fc ON fc.id = i.finance_client_id
WHERE fc.client_id = $1
  AND l.status = 'PENDING'
ORDER BY l.datetime DESC
`

type GetPendingLedgerAllocationsRow struct {
	InvoiceID     int32
	LedgerID      int32
	Reference     string
	Type          string
	Amount        int32
	Notes         pgtype.Text
	Confirmeddate pgtype.Date
	CreatedbyID   pgtype.Int4
	Status        string
	Datetime      pgtype.Timestamp
}

func (q *Queries) GetPendingLedgerAllocations(ctx context.Context, clientID int32) ([]GetPendingLedgerAllocationsRow, error) {
	rows, err := q.db.Query(ctx, getPendingLedgerAllocations, clientID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPendingLedgerAllocationsRow
	for rows.Next() {
		var i GetPendingLedgerAllocationsRow
		if err := rows.Scan(
			&i.InvoiceID,
			&i.LedgerID,
			&i.Reference,
			&i.Type,
			&i.Amount,
			&i.Notes,
			&i.Confirmeddate,
			&i.CreatedbyID,
			&i.Status,
			&i.Datetime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
