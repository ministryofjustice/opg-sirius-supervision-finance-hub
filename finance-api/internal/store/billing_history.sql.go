// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: billing_history.sql

package store

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getAppliedLedgerAllocations = `-- name: GetAppliedLedgerAllocations :many
SELECT i.id invoice_id, l.id ledger_id, i.reference, l.type, la.amount, l.notes, l.createddate, l.createdby_id
FROM ledger_allocation la
         JOIN ledger l ON l.id = la.ledger_id
         JOIN invoice i ON i.id = la.invoice_id
         JOIN finance_client fc ON fc.id = i.finance_client_id
WHERE fc.client_id = $1
AND l.status IN ('APPROVED', 'CONFIRMED')
ORDER BY l.createddate DESC
`

type GetAppliedLedgerAllocationsRow struct {
	InvoiceID   int32
	LedgerID    int32
	Reference   string
	Type        string
	Amount      int32
	Notes       pgtype.Text
	Createddate pgtype.Date
	CreatedbyID pgtype.Int4
}

func (q *Queries) GetAppliedLedgerAllocations(ctx context.Context, clientID int32) ([]GetAppliedLedgerAllocationsRow, error) {
	rows, err := q.db.Query(ctx, getAppliedLedgerAllocations, clientID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAppliedLedgerAllocationsRow
	for rows.Next() {
		var i GetAppliedLedgerAllocationsRow
		if err := rows.Scan(
			&i.InvoiceID,
			&i.LedgerID,
			&i.Reference,
			&i.Type,
			&i.Amount,
			&i.Notes,
			&i.Createddate,
			&i.CreatedbyID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGeneratedInvoices = `-- name: GetGeneratedInvoices :many
SELECT i.id invoice_id, reference, feetype, amount, createddate, createdby_id
FROM invoice i
         JOIN finance_client fc ON fc.id = i.finance_client_id
WHERE fc.client_id = $1
ORDER BY createddate DESC
`

type GetGeneratedInvoicesRow struct {
	InvoiceID   int32
	Reference   string
	Feetype     string
	Amount      int32
	Createddate pgtype.Date
	CreatedbyID pgtype.Int4
}

func (q *Queries) GetGeneratedInvoices(ctx context.Context, clientID int32) ([]GetGeneratedInvoicesRow, error) {
	rows, err := q.db.Query(ctx, getGeneratedInvoices, clientID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetGeneratedInvoicesRow
	for rows.Next() {
		var i GetGeneratedInvoicesRow
		if err := rows.Scan(
			&i.InvoiceID,
			&i.Reference,
			&i.Feetype,
			&i.Amount,
			&i.Createddate,
			&i.CreatedbyID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
