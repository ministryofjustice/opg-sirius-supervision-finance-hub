// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: billing_history.sql

package store

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getFeeReductionEvents = `-- name: GetFeeReductionEvents :many
SELECT
   fr.type,
   fr.startdate,
   fr.enddate,
   fr.datereceived,
   fr.notes,
   fr.created_at,
   fr.created_by,
   fr.cancelled_at,
   fr.cancelled_by,
   fr.cancellation_reason,
   l.status,
   l.amount,
   l.datetime ledger_date,
   fc.client_id,
   i.id invoice_id,
   i.reference reference
FROM fee_reduction fr
JOIN finance_client fc ON fc.id = fr.finance_client_id
LEFT JOIN ledger l ON l.fee_reduction_id = fr.id
LEFT JOIN (SELECT DISTINCT ON (ledger_id) id, ledger_id, invoice_id, datetime, amount, status, reference, notes, allocateddate, batchnumber, source FROM ledger_allocation) la ON l.id = la.ledger_id
LEFT JOIN invoice i ON i.id = la.invoice_id
WHERE fc.client_id = $1
AND (fr.created_at IS NOT NULL OR fr.cancelled_at IS NOT NULL)
`

type GetFeeReductionEventsRow struct {
	Type               string
	Startdate          pgtype.Date
	Enddate            pgtype.Date
	Datereceived       pgtype.Date
	Notes              string
	CreatedAt          pgtype.Timestamp
	CreatedBy          pgtype.Int4
	CancelledAt        pgtype.Timestamp
	CancelledBy        pgtype.Int4
	CancellationReason pgtype.Text
	Status             pgtype.Text
	Amount             pgtype.Int4
	LedgerDate         pgtype.Timestamp
	ClientID           int32
	InvoiceID          pgtype.Int4
	Reference          pgtype.Text
}

func (q *Queries) GetFeeReductionEvents(ctx context.Context, clientID int32) ([]GetFeeReductionEventsRow, error) {
	rows, err := q.db.Query(ctx, getFeeReductionEvents, clientID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetFeeReductionEventsRow
	for rows.Next() {
		var i GetFeeReductionEventsRow
		if err := rows.Scan(
			&i.Type,
			&i.Startdate,
			&i.Enddate,
			&i.Datereceived,
			&i.Notes,
			&i.CreatedAt,
			&i.CreatedBy,
			&i.CancelledAt,
			&i.CancelledBy,
			&i.CancellationReason,
			&i.Status,
			&i.Amount,
			&i.LedgerDate,
			&i.ClientID,
			&i.InvoiceID,
			&i.Reference,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGeneratedInvoices = `-- name: GetGeneratedInvoices :many
SELECT i.id invoice_id, reference, feetype, amount, created_by, created_at
FROM invoice i
         JOIN finance_client fc ON fc.id = i.finance_client_id
WHERE fc.client_id = $1
ORDER BY created_at DESC
`

type GetGeneratedInvoicesRow struct {
	InvoiceID int32
	Reference string
	Feetype   string
	Amount    int32
	CreatedBy pgtype.Int4
	CreatedAt pgtype.Timestamp
}

func (q *Queries) GetGeneratedInvoices(ctx context.Context, clientID int32) ([]GetGeneratedInvoicesRow, error) {
	rows, err := q.db.Query(ctx, getGeneratedInvoices, clientID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetGeneratedInvoicesRow
	for rows.Next() {
		var i GetGeneratedInvoicesRow
		if err := rows.Scan(
			&i.InvoiceID,
			&i.Reference,
			&i.Feetype,
			&i.Amount,
			&i.CreatedBy,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPendingLedgerAllocations = `-- name: GetPendingLedgerAllocations :many
SELECT i.id invoice_id, l.id ledger_id, i.reference, l.type, la.amount, l.notes, l.confirmeddate, l.created_by, l.status, l.datetime
FROM ledger_allocation la
         JOIN ledger l ON l.id = la.ledger_id
         JOIN invoice i ON i.id = la.invoice_id
         JOIN finance_client fc ON fc.id = i.finance_client_id
WHERE fc.client_id = $1
  AND l.status = 'PENDING'
ORDER BY l.datetime DESC
`

type GetPendingLedgerAllocationsRow struct {
	InvoiceID     int32
	LedgerID      int32
	Reference     string
	Type          string
	Amount        int32
	Notes         pgtype.Text
	Confirmeddate pgtype.Date
	CreatedBy     pgtype.Int4
	Status        string
	Datetime      pgtype.Timestamp
}

func (q *Queries) GetPendingLedgerAllocations(ctx context.Context, clientID int32) ([]GetPendingLedgerAllocationsRow, error) {
	rows, err := q.db.Query(ctx, getPendingLedgerAllocations, clientID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPendingLedgerAllocationsRow
	for rows.Next() {
		var i GetPendingLedgerAllocationsRow
		if err := rows.Scan(
			&i.InvoiceID,
			&i.LedgerID,
			&i.Reference,
			&i.Type,
			&i.Amount,
			&i.Notes,
			&i.Confirmeddate,
			&i.CreatedBy,
			&i.Status,
			&i.Datetime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
