// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: billing_history.sql

package store

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getFeeReductionEvents = `-- name: GetFeeReductionEvents :many
SELECT fr.type,
       fr.startdate,
       fr.enddate,
       fr.datereceived,
       fr.notes,
       fr.created_at,
       fr.created_by,
       fr.cancelled_at,
       fr.cancelled_by,
       fr.cancellation_reason
FROM fee_reduction fr
         JOIN finance_client fc ON fc.id = fr.finance_client_id
         LEFT JOIN ledger l ON l.fee_reduction_id = fr.id
         LEFT JOIN (SELECT DISTINCT ON (ledger_id) id, ledger_id, invoice_id, datetime, amount, status, reference, notes, allocateddate, batchnumber, source FROM ledger_allocation) la ON l.id = la.ledger_id
         LEFT JOIN invoice i ON i.id = la.invoice_id
WHERE fc.client_id = $1
  AND (fr.created_at IS NOT NULL OR fr.cancelled_at IS NOT NULL)
`

type GetFeeReductionEventsRow struct {
	Type               string
	Startdate          pgtype.Date
	Enddate            pgtype.Date
	Datereceived       pgtype.Date
	Notes              string
	CreatedAt          pgtype.Timestamp
	CreatedBy          pgtype.Int4
	CancelledAt        pgtype.Timestamp
	CancelledBy        pgtype.Int4
	CancellationReason pgtype.Text
}

func (q *Queries) GetFeeReductionEvents(ctx context.Context, clientID int32) ([]GetFeeReductionEventsRow, error) {
	rows, err := q.db.Query(ctx, getFeeReductionEvents, clientID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetFeeReductionEventsRow
	for rows.Next() {
		var i GetFeeReductionEventsRow
		if err := rows.Scan(
			&i.Type,
			&i.Startdate,
			&i.Enddate,
			&i.Datereceived,
			&i.Notes,
			&i.CreatedAt,
			&i.CreatedBy,
			&i.CancelledAt,
			&i.CancelledBy,
			&i.CancellationReason,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGeneratedInvoices = `-- name: GetGeneratedInvoices :many
SELECT i.id invoice_id, reference, feetype, amount, created_by, created_at
FROM invoice i
         JOIN finance_client fc ON fc.id = i.finance_client_id
WHERE fc.client_id = $1
ORDER BY created_at DESC
`

type GetGeneratedInvoicesRow struct {
	InvoiceID int32
	Reference string
	Feetype   string
	Amount    int32
	CreatedBy pgtype.Int4
	CreatedAt pgtype.Timestamp
}

func (q *Queries) GetGeneratedInvoices(ctx context.Context, clientID int32) ([]GetGeneratedInvoicesRow, error) {
	rows, err := q.db.Query(ctx, getGeneratedInvoices, clientID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetGeneratedInvoicesRow
	for rows.Next() {
		var i GetGeneratedInvoicesRow
		if err := rows.Scan(
			&i.InvoiceID,
			&i.Reference,
			&i.Feetype,
			&i.Amount,
			&i.CreatedBy,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLedgerAllocationsForClient = `-- name: GetLedgerAllocationsForClient :many
SELECT l.id AS ledger_id,
       la.invoice_id,
       i.reference,
       COALESCE(fr.type, l.type),
       la.status,
       l.amount  AS ledger_amount,
       la.amount AS allocation_amount,
       l.datetime AS created_at,
       l.created_by
FROM ledger_allocation la
         JOIN ledger l ON l.id = la.ledger_id
         JOIN finance_client fc ON fc.id = l.finance_client_id
         LEFT JOIN invoice i ON la.invoice_id = i.id
         LEFT JOIN fee_reduction fr ON l.fee_reduction_id = fr.id
WHERE fc.client_id = $1
  AND la.status NOT IN ('PENDING', 'UN ALLOCATED')
`

type GetLedgerAllocationsForClientRow struct {
	LedgerID         int32
	InvoiceID        pgtype.Int4
	Reference        pgtype.Text
	Type             string
	Status           string
	LedgerAmount     int32
	AllocationAmount int32
	CreatedAt        pgtype.Timestamp
	CreatedBy        pgtype.Int4
}

func (q *Queries) GetLedgerAllocationsForClient(ctx context.Context, clientID int32) ([]GetLedgerAllocationsForClientRow, error) {
	rows, err := q.db.Query(ctx, getLedgerAllocationsForClient, clientID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetLedgerAllocationsForClientRow
	for rows.Next() {
		var i GetLedgerAllocationsForClientRow
		if err := rows.Scan(
			&i.LedgerID,
			&i.InvoiceID,
			&i.Reference,
			&i.Type,
			&i.Status,
			&i.LedgerAmount,
			&i.AllocationAmount,
			&i.CreatedAt,
			&i.CreatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPendingInvoiceAdjustments = `-- name: GetPendingInvoiceAdjustments :many
SELECT ia.invoice_id, i.reference, ia.adjustment_type, ia.amount, ia.notes, ia.created_at, ia.created_by
FROM invoice_adjustment ia
         JOIN invoice i ON i.id = ia.invoice_id
         JOIN finance_client fc ON fc.id = ia.finance_client_id
WHERE fc.client_id = $1
ORDER BY ia.raised_date DESC
`

type GetPendingInvoiceAdjustmentsRow struct {
	InvoiceID      int32
	Reference      string
	AdjustmentType string
	Amount         int32
	Notes          string
	CreatedAt      pgtype.Timestamp
	CreatedBy      int32
}

func (q *Queries) GetPendingInvoiceAdjustments(ctx context.Context, clientID int32) ([]GetPendingInvoiceAdjustmentsRow, error) {
	rows, err := q.db.Query(ctx, getPendingInvoiceAdjustments, clientID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPendingInvoiceAdjustmentsRow
	for rows.Next() {
		var i GetPendingInvoiceAdjustmentsRow
		if err := rows.Scan(
			&i.InvoiceID,
			&i.Reference,
			&i.AdjustmentType,
			&i.Amount,
			&i.Notes,
			&i.CreatedAt,
			&i.CreatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPendingRefundsForBillingHistory = `-- name: GetRefundsForBillingHistory :many
SELECT r.id AS refund_id,
       r.raised_date,
       r.amount,
       r.decision,
       r.notes,
       r.created_by,
       r.created_at,
       r.decision_by,
       r.decision_at,
       r.processed_at,
       r.cancelled_at,
       r.fulfilled_at,
       r.cancelled_by
FROM refund r
        JOIN finance_client fc ON fc.id = r.finance_client_id
WHERE fc.client_id = $1
ORDER BY r.created_at DESC
`

type GetRefundsForBillingHistoryRow struct {
	RefundID    int32
	RaisedDate  pgtype.Date
	Amount      int32
	Decision    string
	Notes       string
	CreatedBy   int32
	CreatedAt   pgtype.Timestamp
	DecisionBy  pgtype.Int4
	DecisionAt  pgtype.Timestamp
	ProcessedAt pgtype.Timestamp
	CancelledAt pgtype.Timestamp
	FulfilledAt pgtype.Timestamp
	CancelledBy pgtype.Int4
}

func (q *Queries) GetRefundsForBillingHistory(ctx context.Context, clientID int32) ([]GetRefundsForBillingHistoryRow, error) {
	rows, err := q.db.Query(ctx, getPendingRefundsForBillingHistory, clientID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRefundsForBillingHistoryRow
	for rows.Next() {
		var i GetRefundsForBillingHistoryRow
		if err := rows.Scan(
			&i.RefundID,
			&i.RaisedDate,
			&i.Amount,
			&i.Decision,
			&i.Notes,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.DecisionBy,
			&i.DecisionAt,
			&i.ProcessedAt,
			&i.CancelledAt,
			&i.FulfilledAt,
			&i.CancelledBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRejectedInvoiceAdjustments = `-- name: GetRejectedInvoiceAdjustments :many
SELECT ia.invoice_id, i.reference, ia.adjustment_type, ia.amount, ia.notes, ia.updated_at, ia.updated_by
FROM invoice_adjustment ia
         JOIN invoice i ON i.id = ia.invoice_id
         JOIN finance_client fc ON fc.id = ia.finance_client_id
WHERE fc.client_id = $1
AND status = 'REJECTED'
ORDER BY ia.raised_date DESC
`

type GetRejectedInvoiceAdjustmentsRow struct {
	InvoiceID      int32
	Reference      string
	AdjustmentType string
	Amount         int32
	Notes          string
	UpdatedAt      pgtype.Timestamp
	UpdatedBy      pgtype.Int4
}

func (q *Queries) GetRejectedInvoiceAdjustments(ctx context.Context, clientID int32) ([]GetRejectedInvoiceAdjustmentsRow, error) {
	rows, err := q.db.Query(ctx, getRejectedInvoiceAdjustments, clientID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRejectedInvoiceAdjustmentsRow
	for rows.Next() {
		var i GetRejectedInvoiceAdjustmentsRow
		if err := rows.Scan(
			&i.InvoiceID,
			&i.Reference,
			&i.AdjustmentType,
			&i.Amount,
			&i.Notes,
			&i.UpdatedAt,
			&i.UpdatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
