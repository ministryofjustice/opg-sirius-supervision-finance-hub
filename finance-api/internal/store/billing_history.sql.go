// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: billing_history.sql

package store

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getClientLedgerAllocations = `-- name: GetClientLedgerAllocations :many
SELECT i.id invoice_id,
       l.id ledger_id,
       i.reference,
       l.type ledger_type,
       COALESCE((SELECT type FROM fee_reduction WHERE id = l.fee_reduction_id), '') fee_reduction_type,
       la.amount,
       l.notes,
       l.confirmeddate,
       l.createdby_id,
       l.status,
       l.datetime
FROM ledger_allocation la
         JOIN ledger l ON l.id = la.ledger_id
         JOIN invoice i ON i.id = la.invoice_id
         JOIN finance_client fc ON fc.id = i.finance_client_id
WHERE fc.client_id = $1
  AND l.status IN ('PENDING', 'APPROVED')
ORDER BY l.datetime DESC
`

type GetClientLedgerAllocationsRow struct {
	InvoiceID        int32
	LedgerID         int32
	Reference        string
	LedgerType       string
	FeeReductionType interface{}
	Amount           int32
	Notes            pgtype.Text
	Confirmeddate    pgtype.Date
	CreatedbyID      pgtype.Int4
	Status           string
	Datetime         pgtype.Timestamp
}

func (q *Queries) GetClientLedgerAllocations(ctx context.Context, clientID int32) ([]GetClientLedgerAllocationsRow, error) {
	rows, err := q.db.Query(ctx, getClientLedgerAllocations, clientID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetClientLedgerAllocationsRow
	for rows.Next() {
		var i GetClientLedgerAllocationsRow
		if err := rows.Scan(
			&i.InvoiceID,
			&i.LedgerID,
			&i.Reference,
			&i.LedgerType,
			&i.FeeReductionType,
			&i.Amount,
			&i.Notes,
			&i.Confirmeddate,
			&i.CreatedbyID,
			&i.Status,
			&i.Datetime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGeneratedInvoices = `-- name: GetGeneratedInvoices :many
SELECT i.id invoice_id, reference, feetype, amount, createdby_id, coalesce(confirmeddate, createddate) invoice_date
FROM invoice i
         JOIN finance_client fc ON fc.id = i.finance_client_id
WHERE fc.client_id = $1
ORDER BY COALESCE(confirmeddate, createddate) DESC
`

type GetGeneratedInvoicesRow struct {
	InvoiceID   int32
	Reference   string
	Feetype     string
	Amount      int32
	CreatedbyID pgtype.Int4
	InvoiceDate pgtype.Date
}

func (q *Queries) GetGeneratedInvoices(ctx context.Context, clientID int32) ([]GetGeneratedInvoicesRow, error) {
	rows, err := q.db.Query(ctx, getGeneratedInvoices, clientID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetGeneratedInvoicesRow
	for rows.Next() {
		var i GetGeneratedInvoicesRow
		if err := rows.Scan(
			&i.InvoiceID,
			&i.Reference,
			&i.Feetype,
			&i.Amount,
			&i.CreatedbyID,
			&i.InvoiceDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
