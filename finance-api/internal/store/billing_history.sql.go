// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: billing_history.sql

package store

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getApprovedLedgerAllocations = `-- name: GetApprovedLedgerAllocations :many
SELECT i.id invoice_id, l.id ledger_id, i.reference, fr.type, la.amount, l.notes, l.confirmeddate, l.createdby_id, l.status, l.createddate
FROM ledger_allocation la
         JOIN ledger l ON l.id = la.ledger_id
         JOIN fee_reduction fr on l.fee_reduction_id = fr.id
         JOIN invoice i ON i.id = la.invoice_id
         JOIN finance_client fc ON fc.id = i.finance_client_id
WHERE fc.client_id = $1
  AND l.status = 'APPROVED'
ORDER BY l.datetime DESC
`

type GetApprovedLedgerAllocationsRow struct {
	InvoiceID     int32
	LedgerID      int32
	Reference     string
	Type          string
	Amount        int32
	Notes         pgtype.Text
	Confirmeddate pgtype.Date
	CreatedbyID   pgtype.Int4
	Status        string
	Createddate   pgtype.Date
}

func (q *Queries) GetApprovedLedgerAllocations(ctx context.Context, clientID int32) ([]GetApprovedLedgerAllocationsRow, error) {
	rows, err := q.db.Query(ctx, getApprovedLedgerAllocations, clientID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetApprovedLedgerAllocationsRow
	for rows.Next() {
		var i GetApprovedLedgerAllocationsRow
		if err := rows.Scan(
			&i.InvoiceID,
			&i.LedgerID,
			&i.Reference,
			&i.Type,
			&i.Amount,
			&i.Notes,
			&i.Confirmeddate,
			&i.CreatedbyID,
			&i.Status,
			&i.Createddate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPendingLedgerAllocations = `-- name: GetPendingLedgerAllocations :many
SELECT i.id invoice_id, l.id ledger_id, i.reference, l.type, la.amount, l.notes, l.confirmeddate, l.createdby_id, l.status, l.createddate
FROM ledger_allocation la
         JOIN ledger l ON l.id = la.ledger_id
         JOIN invoice i ON i.id = la.invoice_id
         JOIN finance_client fc ON fc.id = i.finance_client_id
WHERE fc.client_id = $1
  AND l.status = 'PENDING'
ORDER BY l.datetime DESC
`

type GetPendingLedgerAllocationsRow struct {
	InvoiceID     int32
	LedgerID      int32
	Reference     string
	Type          string
	Amount        int32
	Notes         pgtype.Text
	Confirmeddate pgtype.Date
	CreatedbyID   pgtype.Int4
	Status        string
	Createddate   pgtype.Date
}

func (q *Queries) GetPendingLedgerAllocations(ctx context.Context, clientID int32) ([]GetPendingLedgerAllocationsRow, error) {
	rows, err := q.db.Query(ctx, getPendingLedgerAllocations, clientID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPendingLedgerAllocationsRow
	for rows.Next() {
		var i GetPendingLedgerAllocationsRow
		if err := rows.Scan(
			&i.InvoiceID,
			&i.LedgerID,
			&i.Reference,
			&i.Type,
			&i.Amount,
			&i.Notes,
			&i.Confirmeddate,
			&i.CreatedbyID,
			&i.Status,
			&i.Createddate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
