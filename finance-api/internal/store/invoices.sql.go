// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: invoices.sql

package store

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addInvoice = `-- name: AddInvoice :one
INSERT INTO invoice (id, person_id, finance_client_id, feetype, reference, startdate, enddate, amount, confirmeddate,
                     raiseddate, source, created_at, created_by)
VALUES (NEXTVAL('invoice_id_seq'),
        $1,
        (SELECT id FROM finance_client WHERE client_id = $1),
        $2,
        $3,
        $4,
        $5,
        $6,
        NOW(),
        $7,
        $8,
        NOW(),
        $9)
RETURNING id, person_id, finance_client_id, feetype, reference, startdate, enddate, amount, supervisionlevel, confirmeddate, batchnumber, raiseddate, source, scheduledfn14date, cacheddebtamount, created_at, created_by
`

type AddInvoiceParams struct {
	PersonID   pgtype.Int4
	Feetype    string
	Reference  string
	Startdate  pgtype.Date
	Enddate    pgtype.Date
	Amount     int32
	Raiseddate pgtype.Date
	Source     pgtype.Text
	CreatedBy  pgtype.Int4
}

func (q *Queries) AddInvoice(ctx context.Context, arg AddInvoiceParams) (Invoice, error) {
	row := q.db.QueryRow(ctx, addInvoice,
		arg.PersonID,
		arg.Feetype,
		arg.Reference,
		arg.Startdate,
		arg.Enddate,
		arg.Amount,
		arg.Raiseddate,
		arg.Source,
		arg.CreatedBy,
	)
	var i Invoice
	err := row.Scan(
		&i.ID,
		&i.PersonID,
		&i.FinanceClientID,
		&i.Feetype,
		&i.Reference,
		&i.Startdate,
		&i.Enddate,
		&i.Amount,
		&i.Supervisionlevel,
		&i.Confirmeddate,
		&i.Batchnumber,
		&i.Raiseddate,
		&i.Source,
		&i.Scheduledfn14date,
		&i.Cacheddebtamount,
		&i.CreatedAt,
		&i.CreatedBy,
	)
	return i, err
}

const getInvoiceBalanceDetails = `-- name: GetInvoiceBalanceDetails :one
WITH ledger_sums AS (SELECT la.invoice_id,
                            SUM(CASE
                                    WHEN l.status = 'CONFIRMED' AND l.type = 'CREDIT WRITE OFF' AND
                                         la.status = 'ALLOCATED' THEN la.amount
                                    ELSE 0 END) AS write_off_amount,
                            SUM(CASE
                                    WHEN l.status = 'CONFIRMED' AND l.type = 'WRITE OFF REVERSAL' AND
                                         la.status = 'ALLOCATED' THEN la.amount
                                    ELSE 0 END) AS write_off_reversal_amount,
                            SUM(CASE
                                    WHEN l.status = 'CONFIRMED' AND la.status NOT IN ('PENDING', 'UN ALLOCATED')
                                        THEN la.amount
                                    ELSE 0 END) AS received
                     FROM ledger_allocation la
                              JOIN ledger l ON la.ledger_id = l.id
                     GROUP BY la.invoice_id)
SELECT i.amount::INT                                                                          AS initial,
       i.amount - COALESCE(ls.received, 0)::INT                                               AS outstanding,
       i.feetype,
       COALESCE(ls.write_off_amount, 0)::INT + COALESCE(ls.write_off_reversal_amount, 0)::INT AS write_off_amount
FROM invoice i
         LEFT JOIN ledger_sums ls ON ls.invoice_id = i.id
WHERE i.id = $1
`

type GetInvoiceBalanceDetailsRow struct {
	Initial        int32
	Outstanding    int32
	Feetype        string
	WriteOffAmount int32
}

func (q *Queries) GetInvoiceBalanceDetails(ctx context.Context, invoiceID int32) (GetInvoiceBalanceDetailsRow, error) {
	row := q.db.QueryRow(ctx, getInvoiceBalanceDetails, invoiceID)
	var i GetInvoiceBalanceDetailsRow
	err := row.Scan(
		&i.Initial,
		&i.Outstanding,
		&i.Feetype,
		&i.WriteOffAmount,
	)
	return i, err
}

const getInvoiceBalancesForFeeReductionRange = `-- name: GetInvoiceBalancesForFeeReductionRange :many
SELECT i.id,
       i.amount,
       COALESCE(general_fee.amount, 0)::INT               general_supervision_fee,
       i.amount - COALESCE(transactions.received, 0)::INT outstanding,
       i.feetype
FROM invoice i
         JOIN fee_reduction fr ON i.finance_client_id = fr.finance_client_id
         LEFT JOIN LATERAL (
    SELECT SUM(la.amount) AS received
    FROM ledger_allocation la
             JOIN ledger l ON la.ledger_id = l.id AND l.status = 'CONFIRMED'
    WHERE la.status NOT IN ('PENDING', 'UN ALLOCATED')
      AND la.invoice_id = i.id
    ) transactions ON TRUE
         LEFT JOIN LATERAL (
    SELECT SUM(ifr.amount) AS amount
    FROM invoice_fee_range ifr
    WHERE ifr.invoice_id = i.id
      AND ifr.supervisionlevel = 'GENERAL'
    ) general_fee ON TRUE
WHERE i.raiseddate >= (fr.datereceived - INTERVAL '6 months')
  AND i.raiseddate BETWEEN fr.startdate AND fr.enddate
  AND fr.id = $1
`

type GetInvoiceBalancesForFeeReductionRangeRow struct {
	ID                    int32
	Amount                int32
	GeneralSupervisionFee int32
	Outstanding           int32
	Feetype               string
}

func (q *Queries) GetInvoiceBalancesForFeeReductionRange(ctx context.Context, id int32) ([]GetInvoiceBalancesForFeeReductionRangeRow, error) {
	rows, err := q.db.Query(ctx, getInvoiceBalancesForFeeReductionRange, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetInvoiceBalancesForFeeReductionRangeRow
	for rows.Next() {
		var i GetInvoiceBalancesForFeeReductionRangeRow
		if err := rows.Scan(
			&i.ID,
			&i.Amount,
			&i.GeneralSupervisionFee,
			&i.Outstanding,
			&i.Feetype,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getInvoiceCounter = `-- name: GetInvoiceCounter :one
INSERT INTO counter (id, key, counter)
VALUES (NEXTVAL('counter_id_seq'), $1, 1)
ON CONFLICT (key) DO UPDATE
    SET counter = counter.counter + 1
RETURNING counter::VARCHAR
`

func (q *Queries) GetInvoiceCounter(ctx context.Context, key string) (string, error) {
	row := q.db.QueryRow(ctx, getInvoiceCounter, key)
	var counter string
	err := row.Scan(&counter)
	return counter, err
}

const getInvoiceFeeReductionReversalDetails = `-- name: GetInvoiceFeeReductionReversalDetails :one
SELECT (SELECT COALESCE(SUM(amount), 0)
        FROM invoice_adjustment ia
        WHERE ia.invoice_id = $1
          AND ia.adjustment_type = 'FEE REDUCTION REVERSAL'
          AND ia.status = 'APPROVED')         AS reversal_total,
       (SELECT COALESCE(SUM(la.amount), 0)
        FROM ledger l
                 JOIN ledger_allocation la ON l.id = la.ledger_id
        WHERE la.invoice_id = $1
          AND la.status = 'ALLOCATED'
          AND l.fee_reduction_id IS NOT NULL) AS fee_reduction_total
`

type GetInvoiceFeeReductionReversalDetailsRow struct {
	ReversalTotal     pgtype.Int8
	FeeReductionTotal pgtype.Int8
}

func (q *Queries) GetInvoiceFeeReductionReversalDetails(ctx context.Context, invoiceID int32) (GetInvoiceFeeReductionReversalDetailsRow, error) {
	row := q.db.QueryRow(ctx, getInvoiceFeeReductionReversalDetails, invoiceID)
	var i GetInvoiceFeeReductionReversalDetailsRow
	err := row.Scan(&i.ReversalTotal, &i.FeeReductionTotal)
	return i, err
}

const getInvoices = `-- name: GetInvoices :many
SELECT i.id,
       i.raiseddate,
       i.reference,
       i.amount,
       COALESCE(transactions.received, 0)::INT                AS received,
       COALESCE(transactions.fee_reduction_type, '')::VARCHAR AS fee_reduction_type
FROM invoice i
         JOIN finance_client fc ON fc.id = i.finance_client_id
         LEFT JOIN LATERAL (
    SELECT SUM(la.amount) AS received, MAX(fr.type) AS fee_reduction_type
    FROM ledger_allocation la
             JOIN ledger l ON la.ledger_id = l.id AND l.status = 'CONFIRMED'
             LEFT JOIN fee_reduction fr ON l.fee_reduction_id = fr.id
    WHERE la.status NOT IN ('PENDING', 'UN ALLOCATED')
      AND la.invoice_id = i.id
    ) transactions ON TRUE
WHERE fc.client_id = $1
ORDER BY i.raiseddate DESC
`

type GetInvoicesRow struct {
	ID               int32
	Raiseddate       pgtype.Date
	Reference        string
	Amount           int32
	Received         int32
	FeeReductionType string
}

func (q *Queries) GetInvoices(ctx context.Context, clientID int32) ([]GetInvoicesRow, error) {
	rows, err := q.db.Query(ctx, getInvoices, clientID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetInvoicesRow
	for rows.Next() {
		var i GetInvoicesRow
		if err := rows.Scan(
			&i.ID,
			&i.Raiseddate,
			&i.Reference,
			&i.Amount,
			&i.Received,
			&i.FeeReductionType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getInvoicesForReversalByCourtRef = `-- name: GetInvoicesForReversalByCourtRef :many
SELECT i.id, i.amount, (COALESCE(transactions.received, 0)::INT) AS received
FROM invoice i
         JOIN finance_client fc ON fc.id = i.finance_client_id
         LEFT JOIN LATERAL (
    SELECT SUM(la.amount) AS received
    FROM ledger_allocation la
             JOIN ledger l ON la.ledger_id = l.id AND l.status = 'CONFIRMED'
    WHERE la.status NOT IN ('PENDING', 'UN ALLOCATED')
      AND la.invoice_id = i.id
    ) transactions ON TRUE
WHERE fc.court_ref = $1
GROUP BY i.id, i.amount, transactions.received, i.raiseddate
HAVING COALESCE(SUM(transactions.received), 0)::INT > 0
ORDER BY i.raiseddate DESC
`

type GetInvoicesForReversalByCourtRefRow struct {
	ID       int32
	Amount   int32
	Received int32
}

func (q *Queries) GetInvoicesForReversalByCourtRef(ctx context.Context, courtRef pgtype.Text) ([]GetInvoicesForReversalByCourtRefRow, error) {
	rows, err := q.db.Query(ctx, getInvoicesForReversalByCourtRef, courtRef)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetInvoicesForReversalByCourtRefRow
	for rows.Next() {
		var i GetInvoicesForReversalByCourtRefRow
		if err := rows.Scan(&i.ID, &i.Amount, &i.Received); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLedgerAllocations = `-- name: GetLedgerAllocations :many
WITH allocations AS (SELECT la.invoice_id,
                            la.amount,
                            la.datetime AS received_date,
                            l.type,
                            la.status,
                            la.datetime AS created_at,
                            la.id       AS ledger_allocation_id
                     FROM ledger_allocation la
                              JOIN ledger l ON la.ledger_id = l.id
                     WHERE la.invoice_id = ANY ($1::INT[])
                       AND la.status NOT IN ('PENDING', 'UN ALLOCATED')
                       AND l.status = 'CONFIRMED'
                     UNION
                     SELECT ia.invoice_id,
                            ia.amount,
                            ia.raised_date AS received_date,
                            ia.adjustment_type,
                            ia.status,
                            ia.created_at,
                            ia.id
                     FROM invoice_adjustment ia
                     WHERE ia.status = 'PENDING'
                       AND ia.invoice_id = ANY ($1::INT[]))
SELECT invoice_id, amount, received_date, type, status, created_at, ledger_allocation_id
FROM allocations
ORDER BY received_date DESC, created_at DESC, status DESC, ledger_allocation_id ASC
`

type GetLedgerAllocationsRow struct {
	InvoiceID          pgtype.Int4
	Amount             int32
	ReceivedDate       pgtype.Timestamp
	Type               string
	Status             string
	CreatedAt          pgtype.Timestamp
	LedgerAllocationID int32
}

func (q *Queries) GetLedgerAllocations(ctx context.Context, dollar_1 []int32) ([]GetLedgerAllocationsRow, error) {
	rows, err := q.db.Query(ctx, getLedgerAllocations, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetLedgerAllocationsRow
	for rows.Next() {
		var i GetLedgerAllocationsRow
		if err := rows.Scan(
			&i.InvoiceID,
			&i.Amount,
			&i.ReceivedDate,
			&i.Type,
			&i.Status,
			&i.CreatedAt,
			&i.LedgerAllocationID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSupervisionLevels = `-- name: GetSupervisionLevels :many
SELECT invoice_id, supervisionlevel, fromdate, todate, amount
FROM invoice_fee_range
WHERE invoice_id = ANY ($1::INT[])
ORDER BY todate DESC
`

type GetSupervisionLevelsRow struct {
	InvoiceID        pgtype.Int4
	Supervisionlevel string
	Fromdate         pgtype.Date
	Todate           pgtype.Date
	Amount           int32
}

func (q *Queries) GetSupervisionLevels(ctx context.Context, dollar_1 []int32) ([]GetSupervisionLevelsRow, error) {
	rows, err := q.db.Query(ctx, getSupervisionLevels, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSupervisionLevelsRow
	for rows.Next() {
		var i GetSupervisionLevelsRow
		if err := rows.Scan(
			&i.InvoiceID,
			&i.Supervisionlevel,
			&i.Fromdate,
			&i.Todate,
			&i.Amount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUnpaidInvoicesByCourtRef = `-- name: GetUnpaidInvoicesByCourtRef :many
SELECT i.id, (i.amount - COALESCE(transactions.received, 0)::INT) AS outstanding
FROM invoice i
         JOIN finance_client fc ON fc.id = i.finance_client_id
         LEFT JOIN LATERAL (
    SELECT SUM(la.amount) AS received
    FROM ledger_allocation la
             JOIN ledger l ON la.ledger_id = l.id AND l.status = 'CONFIRMED'
    WHERE la.status NOT IN ('PENDING', 'UN ALLOCATED')
      AND la.invoice_id = i.id
    ) transactions ON TRUE
WHERE fc.court_ref = $1
GROUP BY i.id, i.amount, transactions.received, i.raiseddate
HAVING (i.amount - COALESCE(SUM(transactions.received), 0)::INT) > 0
ORDER BY i.raiseddate
`

type GetUnpaidInvoicesByCourtRefRow struct {
	ID          int32
	Outstanding int32
}

func (q *Queries) GetUnpaidInvoicesByCourtRef(ctx context.Context, courtRef pgtype.Text) ([]GetUnpaidInvoicesByCourtRefRow, error) {
	rows, err := q.db.Query(ctx, getUnpaidInvoicesByCourtRef, courtRef)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUnpaidInvoicesByCourtRefRow
	for rows.Next() {
		var i GetUnpaidInvoicesByCourtRefRow
		if err := rows.Scan(&i.ID, &i.Outstanding); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
