// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: invoices.sql

package store

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addFeeReductionToInvoice = `-- name: AddFeeReductionToInvoice :one
WITH filtered_invoices AS (SELECT i.id AS invoice_id, fr.id AS fee_reduction_id
                           FROM invoice i
                                    JOIN fee_reduction fr
                                         ON i.finance_client_id = fr.finance_client_id
                           WHERE i.raiseddate >= (fr.datereceived - interval '6 months')
                             AND i.raiseddate BETWEEN fr.startdate AND fr.enddate
                             AND fr.id in (SELECT fere.id
                                          FROM fee_reduction fere
                                                   JOIN finance_client fc on fere.finance_client_id = fc.client_id
                                          WHERE fc.client_id = $1)
                             AND i.id = $2)
UPDATE invoice i
SET fee_reduction_id = fi.fee_reduction_id
FROM filtered_invoices fi
WHERE i.id = fi.invoice_id
returning fi.fee_reduction_id
`

type AddFeeReductionToInvoiceParams struct {
	ClientID int32
	ID       int32
}

func (q *Queries) AddFeeReductionToInvoice(ctx context.Context, arg AddFeeReductionToInvoiceParams) (int32, error) {
	row := q.db.QueryRow(ctx, addFeeReductionToInvoice, arg.ClientID, arg.ID)
	var fee_reduction_id int32
	err := row.Scan(&fee_reduction_id)
	return fee_reduction_id, err
}

const addFeeReductionToInvoices = `-- name: AddFeeReductionToInvoices :many
WITH filtered_invoices AS (SELECT i.id AS invoice_id, fr.id AS fee_reduction_id
                           FROM invoice i
                                    JOIN fee_reduction fr
                                         ON i.finance_client_id = fr.finance_client_id
                           WHERE i.raiseddate >= (fr.datereceived - interval '6 months')
                             AND i.raiseddate BETWEEN fr.startdate AND fr.enddate
                             AND fr.id = $1)
UPDATE invoice i
SET fee_reduction_id = fi.fee_reduction_id
FROM filtered_invoices fi
WHERE i.id = fi.invoice_id
returning i.id, i.person_id, i.finance_client_id, i.feetype, i.reference, i.startdate, i.enddate, i.amount, i.supervisionlevel, i.confirmeddate, i.batchnumber, i.raiseddate, i.source, i.scheduledfn14date, i.cacheddebtamount, i.createddate, i.createdby_id, i.fee_reduction_id
`

func (q *Queries) AddFeeReductionToInvoices(ctx context.Context, id int32) ([]Invoice, error) {
	rows, err := q.db.Query(ctx, addFeeReductionToInvoices, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Invoice
	for rows.Next() {
		var i Invoice
		if err := rows.Scan(
			&i.ID,
			&i.PersonID,
			&i.FinanceClientID,
			&i.Feetype,
			&i.Reference,
			&i.Startdate,
			&i.Enddate,
			&i.Amount,
			&i.Supervisionlevel,
			&i.Confirmeddate,
			&i.Batchnumber,
			&i.Raiseddate,
			&i.Source,
			&i.Scheduledfn14date,
			&i.Cacheddebtamount,
			&i.Createddate,
			&i.CreatedbyID,
			&i.FeeReductionID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const addManualInvoice = `-- name: AddManualInvoice :one
INSERT INTO invoice (id, person_id, finance_client_id, feetype, reference, startdate, enddate, amount, confirmeddate,
                     batchnumber, raiseddate, source, scheduledfn14date, cacheddebtamount, createddate, createdby_id,
                     fee_reduction_id)
VALUES (nextval('invoice_id_seq'),
        $1,
        (select id from finance_client where client_id = $1),
        $2,
        $3,
        $4,
        $5,
        $6,
        $7,
        $8,
        $9,
        $10,
        $11,
        $12,
        $13,
        $14,
        $15)
returning id, person_id, finance_client_id, feetype, reference, startdate, enddate, amount, supervisionlevel, confirmeddate, batchnumber, raiseddate, source, scheduledfn14date, cacheddebtamount, createddate, createdby_id, fee_reduction_id
`

type AddManualInvoiceParams struct {
	PersonID          pgtype.Int4
	Feetype           string
	Reference         string
	Startdate         pgtype.Date
	Enddate           pgtype.Date
	Amount            int32
	Confirmeddate     pgtype.Date
	Batchnumber       pgtype.Int4
	Raiseddate        pgtype.Date
	Source            pgtype.Text
	Scheduledfn14date pgtype.Date
	Cacheddebtamount  pgtype.Int4
	Createddate       pgtype.Date
	CreatedbyID       pgtype.Int4
	FeeReductionID    pgtype.Int4
}

func (q *Queries) AddManualInvoice(ctx context.Context, arg AddManualInvoiceParams) (Invoice, error) {
	row := q.db.QueryRow(ctx, addManualInvoice,
		arg.PersonID,
		arg.Feetype,
		arg.Reference,
		arg.Startdate,
		arg.Enddate,
		arg.Amount,
		arg.Confirmeddate,
		arg.Batchnumber,
		arg.Raiseddate,
		arg.Source,
		arg.Scheduledfn14date,
		arg.Cacheddebtamount,
		arg.Createddate,
		arg.CreatedbyID,
		arg.FeeReductionID,
	)
	var i Invoice
	err := row.Scan(
		&i.ID,
		&i.PersonID,
		&i.FinanceClientID,
		&i.Feetype,
		&i.Reference,
		&i.Startdate,
		&i.Enddate,
		&i.Amount,
		&i.Supervisionlevel,
		&i.Confirmeddate,
		&i.Batchnumber,
		&i.Raiseddate,
		&i.Source,
		&i.Scheduledfn14date,
		&i.Cacheddebtamount,
		&i.Createddate,
		&i.CreatedbyID,
		&i.FeeReductionID,
	)
	return i, err
}

const getInvoiceBalance = `-- name: GetInvoiceBalance :one
SELECT i.amount initial, i.amount - COALESCE(SUM(la.amount), 0) outstanding, i.feetype
FROM invoice i
         LEFT JOIN ledger_allocation la on i.id = la.invoice_id
    AND la.status <> 'PENDING'
WHERE i.id = $1
group by i.amount, i.feetype
`

type GetInvoiceBalanceRow struct {
	Initial     int32
	Outstanding int32
	Feetype     string
}

func (q *Queries) GetInvoiceBalance(ctx context.Context, id int32) (GetInvoiceBalanceRow, error) {
	row := q.db.QueryRow(ctx, getInvoiceBalance, id)
	var i GetInvoiceBalanceRow
	err := row.Scan(&i.Initial, &i.Outstanding, &i.Feetype)
	return i, err
}

const getInvoices = `-- name: GetInvoices :many
SELECT i.id, i.reference, i.amount, i.raiseddate, i.cacheddebtamount
FROM invoice i
         inner join finance_client fc on fc.id = i.finance_client_id
where fc.client_id = $1
order by i.raiseddate desc
`

type GetInvoicesRow struct {
	ID               int32
	Reference        string
	Amount           int32
	Raiseddate       pgtype.Date
	Cacheddebtamount pgtype.Int4
}

func (q *Queries) GetInvoices(ctx context.Context, clientID int32) ([]GetInvoicesRow, error) {
	rows, err := q.db.Query(ctx, getInvoices, clientID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetInvoicesRow
	for rows.Next() {
		var i GetInvoicesRow
		if err := rows.Scan(
			&i.ID,
			&i.Reference,
			&i.Amount,
			&i.Raiseddate,
			&i.Cacheddebtamount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLedgerAllocations = `-- name: GetLedgerAllocations :many
select la.id, la.amount, la.datetime, l.bankdate, l.type, la.status
from ledger_allocation la
         inner join ledger l on la.ledger_id = l.id
where la.invoice_id = $1
order by la.id desc
`

type GetLedgerAllocationsRow struct {
	ID       int32
	Amount   int32
	Datetime pgtype.Timestamp
	Bankdate pgtype.Date
	Type     string
	Status   string
}

func (q *Queries) GetLedgerAllocations(ctx context.Context, invoiceID pgtype.Int4) ([]GetLedgerAllocationsRow, error) {
	rows, err := q.db.Query(ctx, getLedgerAllocations, invoiceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetLedgerAllocationsRow
	for rows.Next() {
		var i GetLedgerAllocationsRow
		if err := rows.Scan(
			&i.ID,
			&i.Amount,
			&i.Datetime,
			&i.Bankdate,
			&i.Type,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSupervisionLevels = `-- name: GetSupervisionLevels :many
select supervisionlevel, fromdate, todate, amount
from invoice_fee_range
where invoice_id = $1
order by todate desc
`

type GetSupervisionLevelsRow struct {
	Supervisionlevel string
	Fromdate         pgtype.Date
	Todate           pgtype.Date
	Amount           int32
}

func (q *Queries) GetSupervisionLevels(ctx context.Context, invoiceID pgtype.Int4) ([]GetSupervisionLevelsRow, error) {
	rows, err := q.db.Query(ctx, getSupervisionLevels, invoiceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSupervisionLevelsRow
	for rows.Next() {
		var i GetSupervisionLevelsRow
		if err := rows.Scan(
			&i.Supervisionlevel,
			&i.Fromdate,
			&i.Todate,
			&i.Amount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertCounterForInvoiceRefYear = `-- name: UpsertCounterForInvoiceRefYear :one
INSERT INTO counter (id, key, counter)
VALUES (nextval('counter_id_seq'), $1, 1)
ON CONFLICT (key) DO UPDATE
    SET counter = counter.counter + 1
RETURNING id, key, counter
`

func (q *Queries) UpsertCounterForInvoiceRefYear(ctx context.Context, key string) (Counter, error) {
	row := q.db.QueryRow(ctx, upsertCounterForInvoiceRefYear, key)
	var i Counter
	err := row.Scan(&i.ID, &i.Key, &i.Counter)
	return i, err
}
